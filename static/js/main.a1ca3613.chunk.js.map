{"version":3,"sources":["components/Player/Player.js","helpers/coordinatesHelper.js","components/Background/Background.js","App.js","serviceWorker.js","index.js"],"names":["spritesheets","left","right","Player","useState","x","y","direction","frames","pressed","coordinates","setCoordinates","handleUserKeyPress","e","key","handleUserKeyUnPress","useEffect","timeOut","setTimeout","retObj","moveHandler","clearTimeout","window","addEventListener","removeEventListener","AnimatedSprit","PixiComponent","create","props","PIXI","textures","applyProps","instance","oldProps","newProps","animationSpeed","gotoAndPlay","app","useApp","React","loader","add","Object","values","load","_","resource","state","keys","data","map","frame","from","length","resources","initialFrame","anchor","Background","width","height","image","scale","App","Boolean","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.a1ca3613.chunk.js","sourcesContent":["import React, {useCallback, useEffect, useState} from \"react\";\nimport {PixiComponent, Container, useApp} from \"@inlet/react-pixi\";\nimport * as PIXI from \"pixi.js\";\nimport {moveHandler} from \"../../helpers/coordinatesHelper\";\n\nlet spritesheets = {left: 'assets/spritesheetLeft.json', right: 'assets/spritesheetRight.json'}\nconst tick = 50;\nexport const Player = () => {\n  const [coordinates, setCoordinates] = useState({x: 250, y: 250, direction: 'left', frames: [], pressed: ''})\n  const handleUserKeyPress = (e) => (coordinates.pressed !== e.key) ? (setCoordinates({\n    ...coordinates,\n    pressed: e.key\n  })) : (() => {\n  });\n  const handleUserKeyUnPress = (e) => setCoordinates({...coordinates, pressed: ''})\n  useEffect(() => {\n      const timeOut = setTimeout(() => {\n        if (coordinates.pressed !== '')\n          setCoordinates({...coordinates, ...moveHandler(coordinates)})\n      }, tick);\n      return () => clearTimeout(timeOut)\n    }\n  )\n  useEffect(() => {\n    window.addEventListener('keydown', handleUserKeyPress)\n    window.addEventListener('keyup', handleUserKeyUnPress)\n    return () => {\n      window.removeEventListener('keyup', handleUserKeyUnPress);\n      window.removeEventListener('keydown', handleUserKeyPress);\n    }\n  }, [handleUserKeyPress])\n  const AnimatedSprit = PixiComponent('AnimatedSprit', {\n    create: props => {\n      return new PIXI.AnimatedSprite(props.textures)\n    },\n    applyProps: (instance, oldProps, newProps) => {\n      instance.animationSpeed = newProps.animationSpeed;\n      instance.textures = newProps.textures;\n      if (newProps.pressed===''){\n        instance.gotoAndPlay(0);\n        instance.animationSpeed = 0;\n      }\n      instance.gotoAndPlay(0);\n    }\n  })\n  const app = useApp();\n  React.useEffect(() => {\n    app.loader.add(Object.values(spritesheets)).load((_, resource) => {\n      setCoordinates((state) => {\n          return {\n            ...state,\n            frames: Object.keys(resource[spritesheets[coordinates.direction]].data.frames).map(frame =>\n              PIXI.Texture.from(frame)\n            )\n          }\n        }\n      );\n    });\n  }, [spritesheets]);\n  React.useEffect(() => {\n      if (coordinates.frames.length > 0)\n        setCoordinates({\n          ...coordinates,\n          frames: Object.keys(app.loader.resources[spritesheets[coordinates.direction]].data.frames).map(frame => PIXI.Texture.from(frame))\n        })\n    }\n    , [coordinates.direction])\n  if (coordinates.frames.length === 0) {\n    return null;\n  }\n  return (\n    <Container x={coordinates.x} y={coordinates.y}>\n      <AnimatedSprit\n        animationSpeed={0.3}\n        initialFrame={0}\n        pressed={coordinates.pressed}\n        textures={coordinates.frames}\n        anchor={1}\n      />\n    </Container>\n  );\n\n}","const STEP = 10\nexport const moveHandler = (coordinates) => {\n  let retObj = coordinates;\n  switch (coordinates.pressed) {\n    case 'ArrowRight':\n      coordinates.x += STEP;\n      coordinates.direction = 'right';\n      break;\n    case 38:\n      coordinates.y -= STEP;\n      break;\n    case 'ArrowLeft':\n      coordinates.x -= STEP;\n      coordinates.direction = 'left';\n      break;\n    case 40:\n      coordinates.y += STEP;\n      break;\n    case 32:\n      break;\n    default:\n      return;\n  }\n  return retObj\n}","import React from \"react\";\nimport {Sprite, Container, useApp} from \"@inlet/react-pixi\";\nimport * as PIXI from \"pixi.js\";\n\nconst image = 'assets/FIELD9.png'\n\nexport const Background = () => {\n  return (<Container width={640} height={480}>\n    <Sprite\n      image={image}\n      scale={{x: 1, y: 1}}\n    >\n\n\n    </Sprite>\n  </Container>)\n}","import React, {useCallback, useEffect, useState} from 'react';\nimport './App.css';\n\nimport {Stage,} from '@inlet/react-pixi';\nimport {Player} from \"./components/Player/Player\";\nimport {Background} from \"./components/Background/Background\";\n\nconst [width, height] = [640, 480];\n\n\nconst App = () => {\n\n\n  return (\n    <Stage width={width} height={height}>\n      <Background/>\n      <Player/>\n    </Stage>\n  );\n}\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}